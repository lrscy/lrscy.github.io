{"meta":{"title":"Meow","subtitle":null,"description":null,"author":"Ruosen Li","url":"https://lrscy.github.io"},"pages":[{"title":"","date":"2017-11-10T11:14:16.259Z","updated":"2017-11-10T11:14:16.259Z","comments":true,"path":"404.html","permalink":"https://lrscy.github.io/404.html","excerpt":"","text":"Page not found &bull; enStyled #loading body { opacity: 1; transform: none; } var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-396787-1']); _gaq.push(['_trackPageview']); _gaq.push(['_trackPageLoadTime']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })(); !function(a,b){\"object\"==typeof module&&module.exports?module.exports=b():\"function\"==typeof define&&define.amd?define(b):a.Spinner=b()}(this,function(){\"use strict\";function a(a,b){var c,d=document.createElement(a||\"div\");for(c in b)d[c]=b[c];return d}function b(a){for(var b=1,c=arguments.length;c>b;b++)a.appendChild(arguments[b]);return a}function c(a,b,c,d){var e=[\"opacity\",b,~~(100*a),c,d].join(\"-\"),f=.01+c/d*100,g=Math.max(1-(1-a)/b*(100-f),a),h=j.substring(0,j.indexOf(\"Animation\")).toLowerCase(),i=h&&\"-\"+h+\"-\"||\"\";return m[e]||(k.insertRule(\"@\"+i+\"keyframes \"+e+\"{0%{opacity:\"+g+\"}\"+f+\"%{opacity:\"+a+\"}\"+(f+.01)+\"%{opacity:1}\"+(f+b)%100+\"%{opacity:\"+a+\"}100%{opacity:\"+g+\"}}\",k.cssRules.length),m[e]=1),e}function d(a,b){var c,d,e=a.style;if(b=b.charAt(0).toUpperCase()+b.slice(1),void 0!==e[b])return b;for(d=0;d>1,filter:i}),c(\"fill\",{color:g(d.color,a),opacity:d.opacity}),c(\"stroke\",{opacity:0}))))}var i,j=d.scale*(d.length+d.width),k=2*d.scale*j,l=-(d.width+d.length)*d.scale*2+\"px\",m=e(f(),{position:\"absolute\",top:l,left:l});if(d.shadow)for(i=1;i"},{"title":"tags","date":"2017-11-09T08:37:18.000Z","updated":"2017-11-09T09:16:27.398Z","comments":false,"path":"tags/index.html","permalink":"https://lrscy.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"从零起步搭建配置github.io博客——Hexo","slug":"Github-io-config-Hexo","date":"2017-11-09T16:00:00.000Z","updated":"2017-11-10T11:01:56.892Z","comments":true,"path":"2017/11/10/Github-io-config-Hexo/","link":"","permalink":"https://lrscy.github.io/2017/11/10/Github-io-config-Hexo/","excerpt":"","text":"前言本文利用Github io和Hexo搭建静态博客。主题更换等问题请到Hexo Theme里寻找并替换。 继上次用Jekyll搭建博客后，又忙了很多其他事情，接触到了Hexo。因此决定将博客从Jekyll换到Hexo。 本人是个前端小白，按照网上众多教程搭建时候依旧踩了很多坑，在此记录下来以便有相同问题的同学可以快速解决。 搭建Github io静态博客所需基础之基础的知识如下： Git Github Markdown Hexo 本文是在Ubuntu 17.04环境下配置的，如果使用其他操作系统请自行查找对应命令或者解决方案。 以下代码区域，带有$打头的表示需要在控制台（终端或称命令行）下面执行（不包括$符号）。如果出现权限不足提示请在命令最前面加上sudo再执行。 本文几乎所有命令都可以直接拷到控制台（终端或称命令行）内直接执行而不用理解其具体含义（除非特殊表明需要修改），但是强烈不建议这么做！！！ 我是基于Hexo模板搭建的博客，所以不会讲如何从零手敲出一个博客样式出来，但会比较详细的讲模板中哪里需要修改。 基础环境搭建Git/Github/SSH配置详见我的博客「Github配置」。 Node.js安装安装Hexo前需要安装Node.js，本人安装的是Node.js 8。 对于Ubuntu系列系统，执行以下两个命令：12$ curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -$ sudo apt-get install -y nodejs 如果系统中没有安装curl，执行下述命令安装：1$ sudo apt-get install curl 安装完成后需要检查下node和npm的版本：12$ node -v$ npm -v 分别显示出版本号就算安装完成了～本站搭建时node版本为v8.9.1，npm版本为5.5.1。 参考资料Node.js官网。 Hexo本地建站Hexo安装Hexo安装非常简单，上述环境搭建好后只需执行以下命令即可：1$ npm install -g hexo-cli 本站搭建时Hexo的版本是3.4.0。 Hexo本地建站首先通过终端进入希望建站的文件夹内（例如~/Hexo），执行以下命令：1$ hexo init 该命令要求建站文件夹是全空的文件夹。如果之前在该文件夹内建立了git等文件/文件夹，请先移出文件夹，建站完成后再移回来。该命令会在该文件夹下建立所有需要的文件。接下来安装依赖包：1$ npm install 至此，Hexo本地博客已经搭建完成。对，你没看错～ 然后执行以下命令来浏览本地站点12$ hexo generate$ hexo server hexo generate是用来编译生成站点，每次对站点内容编辑后都要进行该项操作。可以简化为hexo g。hexo server是用来启动本地站点，执行后即可在浏览器中输入localhost:4000查看。可以简化为hexo s。 参考资料Hexo 官方文档 Github io部署博客_config.yml参数设置部署配置在_config.yml文件的末尾，默认样子如下：12345# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: repo: 修改后如下：123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: http://github.com/xxx/xxx.github.io.git(xxx是Github账户名称) branch: master 由于是部署到Github中，所以type是git。repo是指Github对应仓库的SSH地址。点击该仓库页面右侧绿色download，里面的地址就是SSH地址。branch是指上传到Github的哪个分支，如果没特殊需求选择master就可以。特殊需求请自行填写上传哪个branch。 插件安装为了部署到Github上，需要安装hexo-deployer-git插件，命令如下：1$ npm install hexo-deployer-git --save 最终部署最终部署需要输入以下两个命令：12$ hexo generate$ hexo deploy hexo generate同上。hexo deploy将hexo部署到Github io上。可以简化为hexo d。 上传后需要等待几分钟，然后就可以在浏览器中输入xxx.github.io来欣赏了喵～ 参考资料Hexo 部署","categories":[],"tags":[{"name":"Github.io","slug":"Github-io","permalink":"https://lrscy.github.io/tags/Github-io/"},{"name":"Hexo","slug":"Hexo","permalink":"https://lrscy.github.io/tags/Hexo/"}]},{"title":"Ubuntu 16.04 LTS下(多)SSH配置","slug":"SSH-config","date":"2017-05-01T16:00:00.000Z","updated":"2017-11-09T08:28:18.115Z","comments":true,"path":"2017/05/02/SSH-config/","link":"","permalink":"https://lrscy.github.io/2017/05/02/SSH-config/","excerpt":"","text":"本文记录了我配置同机多SSH时候的全过程。 本文是在Ubuntu 16.04 LTS下配置的，如果使用其他操作系统请自行查找对应命令或解决方案。 以下代码区域，带有$打头的表示需要在控制台（终端或称命令行）下面执行（不包括$符号） SSH安装Ubuntu 16.04 LTS自带openssh客户端，但是不带openssh服务器端。如果需要ssh localhost连接本地，那么需要安装openssh-server，命令如下：1$ sudo apt-get install openssh-server 如果你的机器上没有装客户端的话需要执行以下命令安装：1$ sudo apt-get install openssh-client 至此，基础环境已经安装完了。 单SSH配置此节操作只适用于只需要免密码登录一个远程服务器的同学，如果你需要同时SSH远程登录多个服务器，那么请直接跳至下一节。 对于单SSH配置，你只需要输入以下命令即可，此时为默认状态，你的个人信息不会被加入进去：1$ ssh-keygen -t rsa 如果你需要将个人信息（如邮箱）加入进去（比如远程访问Github时），那么请执行如下命令：1$ ssh-keygen -t rsa -C \"youraddress@youremail.com\" 这里有几点需要注意的： -C中的C是大写字母 youraddress@youremail.com是你Github的注册邮箱 对于上述两条命令，如果你远程登录时候需要设置密码，那么请在其提示时候输入密码。然后一路回车即可。 然后你会发现在你的家目录（~或者/home/username/）下多了一个叫做.ssh的文件夹，里面有两个文件id_rsa和id_rsa.pub。这两个就是SSH生成的文件，你需要将公钥传给远程服务器（Github相关问题详见Github配置博文），然后就可以免密码远程登录了。 多SSH配置建立不同的SSH配置文件首先你需要在家目录（~或者/home/username/）下建立一个.ssh文件夹，命令如下：1$ mkdir .ssh 然后进入该文件夹（建议进入）：1$ cd ~/.ssh 在该文件夹下，输入以下命令，后面我会介绍每个参数的作用：1$ ssh-keygen -t rsa -f ~/.ssh/id_rsa.blabla 如果你需要将个人信息（如邮箱）加入进去（比如远程访问Github时），那么请执行如下命令：1$ ssh-keygen -t rsa -f ~/.ssh/id_rsa.blabla -C \"youraddress@youremail.com\" 下面我们来分析下这两个命令。 -t rsa是指定你的加密算法。 -f是指定你的文件存储位置，我建议存在~/.ssh文件夹中。文件明明我建议按照我的格式写，blabla是该SSH配置文件的用途，比如.github, .localhost之类的。 -C注意这里C是大写字母。这里填写你的邮箱地址（顺便提一句配置Github时一定要填写你的注册邮箱，详见Github配置）。 建立索引因为你有多对SSH配置文件（.blabla和.blabla.pub是一对私钥和公钥），所以在远程登陆时，系统需要知道你需要将哪份私钥和远程的公钥进行匹配。所以你需要一个索引文件config。输入如下命令建立该文件：1$ touch config 文件格式如下：1234Host name HostName hostname User username IdentityFile filepath 一个config文件中可以有多个上述结构，每个结构之间建议用一个空行隔开。下面解析下这个结构。 Host就是个名字，每个结构之间不得重复 HostName是远程主机的域名，比如github.com, localhost之类或者是一个固定的IP地址。 User就是你登录该远程主机的用户名。 IdentityFile就是对应该主机的私钥的文件路径。依上述教程，应为~/.ssh/id_rsa.blabla。 登录localhost在配置软件环境时，有软件需要免密码登录localhost，也就是免密码登录本机。此时，你需要在.ssh目录下建立authorized_keys文件，命令如下：1$ touch authorized_keys 建立此文件的目的是存储已知的SSH公钥信息。此时你需要将localhost的公钥复制进来。 如果你是单SSH配置，则需要把id_rsa.pub文件复制进来。命令如下：1$ cat id_rsa.pub &gt;&gt; authorized_keys 如果你是多SSH配置，依上述教程，你需要把id_rsa.localhost.pub复制进来，命令如下：1$ cat id_rsa.localhost.pub &gt;&gt; authorized_keys 然后你就可以免密码登录localhost了。另外，如果需要添加其他已知SSH公钥的话，直接往authorized_keys中添加即可。 常见提示及应对方法第一次登录第一次远程登录一个新的主机时一般会出现如下提示：123The authenticity of host 'xxx.com (xx.xx.xx.xx)' can't be established.RSA key fingerprint is xx:xx...xx:xx.Are you sure you want to continue connecting (yes/no)? 1输入yes即可。然后可能会出现如下警告，意味着要永久存储该机器的特征信息，不用理睬即可： Warning: Permanently added ‘xxx.com,xx.xx.xx.xx’ (RSA) to the list of known hosts.``` known_hosts文件当你访问远程主机时，系统会记录远程主机的特征信息，这些信息都存储在known_hosts里面。如果你不小心删掉了的话，也没什么事请，就是下一次进行SSH链接时还会出现第一次登录的提示，按照提示输入yes即可。","categories":[],"tags":[{"name":"SSH","slug":"SSH","permalink":"https://lrscy.github.io/tags/SSH/"}]},{"title":"Github配置","slug":"Github-config","date":"2017-04-30T16:00:00.000Z","updated":"2017-11-09T08:27:33.146Z","comments":true,"path":"2017/05/01/Github-config/","link":"","permalink":"https://lrscy.github.io/2017/05/01/Github-config/","excerpt":"","text":"本文记录了我配置Github时候的全过程。 本文是在Ubuntu 16.04LTS下配置的，如果使用其他操作系统请自行查找对应命令或解决方案。 以下代码区域，带有$打头的表示需要在控制台（终端或称命令行）下面执行（不包括$符号） Git安装Ubuntu下需要安装git，输入命令如下：1$ sudo apt-get install git Github账户注册你需要一个Github的账户才能使用github.io服务。所以去github.com点击右上角的Sign Up注册即可。 SSH配置我们需要使用ssh来和github上的远程仓库进行通信，所以需要检查和配置ssh。 首先需要检查电脑上现有的ssh key:1$ cd ~/.ssh 如果提示：No such file or dictionary 则说明你是第一次使用git。 如果你是第一次使用git，那么你需要做如下工作。否则可以跳过此节。 生成新的SSH KEY:1$ ssh-keygen -t rsa -C \"youraddress@youremail.com\" 这里有几点需要注意的： -C中的C是大写字母 youraddress@youremail.com是你Github的注册邮箱 其余的一路回车就能完成了。其中.pub是公钥，需要给到远程主机上，这点我们下一节再讲。 如果你需要连接多ssh终端，那么请自行搜索“多ssh配置”。 Github配置仅仅本地配置好了是不够的，你需要让你的github账户认识你。所以你需要按照以下步骤操作： 去登录github账户，在右上角点击头像找到Settings 点进去后点击左侧栏中的SSH and GPG keys 点击右侧New SSH key 随意输入个能带便当前机器的名字，并把本地.ssh目录下生成的关于github的.pub文件拷贝进来 保存即可 Github连接检查当一切配置妥当后，在终端中输入1$ ssh -T git@github.com 如果你是第一次输入此命令，可能遇到如下提示：123The authenticity of host 'github.com (207.97.227.239)' can't be established.RSA key fingerprint is xx:xx...xx:xx.Are you sure you want to continue connecting (yes/no)? 此时输入yes即可，然后会出现：1Hi xxx! You've successfully authenticated, but GitHub does not provide shell access. 此时表明你的github配置完成了 本地个人信息配置此时你已经可以通过SSH连接到Github了，但是还有一些个人信息需要完善才能够和Github愉快的通信。 Git会依据本地设定的用户名和邮箱向远程主机提交更改，Github也是依据这些信息进行权限管理的。如果你当前只使用一个Github帐号，那么你需要以下两个命令来完善本地个人信息设定：12$ git config --global user.name \"your github name\"$ git config --global user.email \"youraddress@youremail.com\" 上述命令中your github name是你的github用户名，youraddress@youremail.com是你github的注册邮箱。 如果你需要配置多Github账户，则需要用如下命令将–global所设置的参数撤销掉：12$ git config --global unset user.name$ git config --global unset user.email 在每个git根目录下自行建立个人信息，命令如下：12$ git config user.name \"your github name\"$ git config user.email \"youraddress@youremail.com\" 上述命令中your github name是你的github用户名，youraddress@youremail.com是你github的注册邮箱。 至此，Git/Github已全部完成。","categories":[],"tags":[{"name":"Github","slug":"Github","permalink":"https://lrscy.github.io/tags/Github/"},{"name":"SSH","slug":"SSH","permalink":"https://lrscy.github.io/tags/SSH/"}]},{"title":"Ruby基础配置","slug":"Ruby-base-config","date":"2017-04-30T16:00:00.000Z","updated":"2017-11-09T08:28:25.331Z","comments":true,"path":"2017/05/01/Ruby-base-config/","link":"","permalink":"https://lrscy.github.io/2017/05/01/Ruby-base-config/","excerpt":"","text":"Note: 本文内容节选复述了Ruby-China中的教程中的内容，其中有一两步和原版有出入（我踩到的坑）。如果需要看原版内容请点击上述链接。 本文是在Ubuntu 16.04LTS环境下配置的，如果使用其他操作系统请自行查找对应命令或解决方案。 以下代码区域，带有$打头的表示需要在控制台（终端或称命令行）下面执行（不包括$符号） 由于ubuntu自带的ruby版本太老，所以需要从下列途径更新。 安装系统需要的包12$ sudo apt-get install curl$ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 其中curl是一种下载工具，在后续操作中需要用到。 安装RVM1234$ gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3$ curl -sSL https://get.rvm.io | bash -s stable# 如果上面的连接失败，可以尝试: $ curl -L https://raw.githubusercontent.com/wayneeseguin/rvm/master/binscripts/rvm-installer | bash -s stable 如果其中某些命令出现权限不足提醒，则在前面添加sudo再执行即可。 接下来载入RVM环境1$ source ~/.rvm/scripts/rvm 接下来有一点和教程中不太一样（我踩到的坑）。打开~/.bash_profile文件你可能发现如下一行：1[[ -s \"$HOME/.rvm/scripts/rvm\" ]] &amp;&amp; source \"$HOME/.rvm/scripts/rvm\" # Load RVM into a shell session *as a function* 原文中说“新开的终端就不想要这么做了，会自动重新载入的”正因为RVM安装程序在.bash_profile中添加了这么一行。然而你可能发现现实很残酷，新开的终端并没有载入rvm环境。此时你需要在家目录（～）下的.bashrc文件中的末尾添加如下几行：12# Add RVM to PATH for scripting. Make sure this is the last PATH variable change.[[ -s \"$HOME/.rvm/scripts/rvm\" ]] &amp;&amp; source \"$HOME/.rvm/scripts/rvm\" 其实也就是复制到.bashrc中而已。然后重启终端即可，如果还不行那么注销重新登录即可，如果还不行请重启机器。 然后修改RVM下的Ruby源，到Ruby China的镜像：1$ echo \"ruby_url=https://cache.ruby-china.org/pub/ruby\" &gt; ~/.rvm/user/db 检查下是否安装正确1$ rvm -v 用RVM按转Ruby环境12$ rvm requirements$ rvm instll 2.4.0 这里的版本号（2.4.0）可以通过下属命令查看并可修改：1$ rvm list 设置Ruby版本RVM 安装好后，需要执行下述命令将指定版本设为系统默认版本1$ rvm use 2.4.0 --default 这个时候你可以测试是否正确12$ ruby -v$ gem -v 这里你可以替换原有的gem源到Ruby China的源或者淘宝源，分别是：12$ gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/$ gem sources --add https://ruby.taobao.org/ --remove https://rubygems.org/ 可以通过下属命令查看gem源：1$ gem sources -l 接下来安装Bundler1$ gem install bundler 设置Rails环境输入以下命令就可以轻松安装上Rails了：1$ gem install rails 测试是否安装正确1$ rails -v 至此，Ruby基础安装教程到此结束喵～","categories":[],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"https://lrscy.github.io/tags/Ruby/"}]},{"title":"从零起步搭建配置gtihub.io博客——Jekyll","slug":"Github-io-config-Jekyll","date":"2017-04-29T16:00:00.000Z","updated":"2017-11-10T03:54:25.067Z","comments":true,"path":"2017/04/30/Github-io-config-Jekyll/","link":"","permalink":"https://lrscy.github.io/2017/04/30/Github-io-config-Jekyll/","excerpt":"","text":"本文旨在将我配置github.io博客全过程展现出来，帮助从零起步的小白们一步一步的配置属于自己的github.io博客。如果过程正哪一步骤错了，请各位大佬指出，谢谢～ 小白的入门门槛： 需要耐心，耐心，耐心 碰到问题自主去学习和在网上寻找答案 本文是在Ubuntu 16.04LTS环境下配置的，如果使用其他操作系统请自行查找对应命令或解决方案。 以下代码区域，带有$打头的表示需要在控制台（终端或称命令行）下面执行（不包括$符号） 本文几乎所有命令都可以直接拷到控制台（终端或称命令行）内直接执行而不用理解其具体含义（除非特殊表明需要修改），但是强烈不建议这么做！！！ 我是基于Jekyll模板搭建的博客，所以不会讲如何从零手敲出一个博客样式出来，但会比较详细的讲模板中哪里需要修改。 基础环境搭建Git/Github/SSH配置详见我的博客「Gtihub配置」。 本地Jekyll环境配置因为github.io博客是基于Jekyll模板生成的，所以需要了解下Jekyll模板。其实本地不配置Jekyll也是可以的，不过后果就是无法进行本地预览。提交到Github上平均需要10分钟才能看到更改结果，所以我是建议本地配置下Jekyll的。 Ruby安装配置Jekyll是基于ruby的，所以要安装Jekyll还需要安装ruby, gem等。不过不要担心，我已经把雷都踩过了，你只需要跟着我一步步走就好。不过，我们不需要把Rails环境配上，因为我们暂时用不到。 详见我的博客「Ruby基础配置」。 Jekyll安装配置由于上一步已经安装好了Ruby和gem了，所以只需要下面一条命令就可以安上Jekyll：1$ gem install jekyll 没了，嗯～ 真的没骗你～喵～ 至此基础环境搭建也就完成了。 Jekyll目录介绍我会对Jekyll目录进行一个简单粗略的介绍，让你知道每个目录大概都是做什么的，便于你以后查找需要修改的文件的位置。 Note: 我的博客是基于其他作者些的Jekyll主题改的，所以以下部分所述“不需要修改”皆出于此出发点。对于有前端基础的同学请自行忽略。 下面是目录树：123456789101112131415161718192021blog _includes footer.html head.html header.html _layouts default.html page.html post.html _posts 2017-04-30-Hello.md _sass _site css main.scss .gitignore .sass-cache _config.yml about.md feed.xml index.html _include{:.no_toc} 这里都是网页模块文件，用来加载到你的布局或文章中。以后可能需要修改部分内容。 可以在其他文件中采用如下方法调用该文件夹内文件：1&#123; % include file %&#125; Note: 调用时候把{和%之间的空格去掉 _layouts{:.no_toc} 存放网页模板。每个网页只需要关注自己的内容。也基本上不用修改。 _posts{:.no_toc} 这里就是存放我们博文的地方了。文件名称非常非常关键，必须使用统一的格式：1YEAR-MONTH-DAY-TITLE.md 中间不能有空格。例如：2017-04-30-Hello.md。不是此格式的博文不会被解析也不会在网站中显示。 _sass{:.no_toc} 存放网站用到的sass文件。基本上你不用管这里面做了些什么。 _site{:.no_toc} 在Jekyll解析完成这些文件后，会将最终的静态网站源代码默认的放在这个文件夹下来保存。这个文件夹最好添加进.gitignore文件中（这个问题我们后面再说）。 css{:.no_toc} 存放网页样式文件。基本上也不用管。 .sass-cache{:.no_toc} sass的编译缓存文件。基本上你不用管这里面都是什么。 _config.yml{:.no_toc} 最重要的配置文件，这里面决定了Jekyll如何解析网站源代码。官方有给出配置文件详细信息，详情请见这里` _plugins{:.no_toc} 你可能需要这个文件夹也可能不需要，按需建立此文件夹。这里用来存放Jekyll插件。 正式开始搭建博客终于开始搭博客了喵～ Github仓库建立本节是在复述官方教程中的内容。 建立一个仓库你需要在你的Github中建立一个新的仓库，名字必须是{your github username}.github.io，否则Github不会将其认为是Github博客。 克隆到本地采用下述命令进行复制1$ git clone https://github.com/username/username.github.io 这里的username是你的github用户名 至此，Github部分完结 Jekyll模板我的博客是基于Pithy主题建立的。Jekyll模板可以从Jekyll Theme上或大佬们的Github上下载。下载解压后直接将所有文件都拷贝到自己刚克隆下来的文件夹下即可。 _config.yml{:.no_toc} 解压后唯一需要修改的部分，修改其中所有你认识的英文，如果没有可以填的空着就好。 接下来你需要做的就是将其push到远程仓库里。如果你不熟悉Git操作命令，我强烈建议你去看下廖雪峰的Git教程。 添加.gitignore文件上文介绍jekyll结构的时候说了句_site要加入.gitignore文件中。.gitignore文件是git上传时要过滤掉的文件。依据自己需求改下就可以了。我目前的.gitignore文件如下：1234_site/*.sass-cache.jekyll-metadata.swp 搭完了，嗯，你没看错，搭完了喵～ 添加Mathjax支持作为一个技术小白，就算再小白也有需要用到数学公式的时候。这时mathjax能满足你的大部分需求。Mathjax配置很简单，过程如下： 在_include/head.html中添加以下代码：1234567891011&lt;script type=\"text/x-mathjax-config\"&gt; MathJax.Hub.Config(&#123; TeX: &#123; equationNumbers: &#123; autoNumber: \"AMS\" &#125; &#125;, tex2jax: &#123; inlineMath: [ ['$','$'], ['\\\\(', '\\\\)'] ], displayMath: [ ['$$','$$'] ], processEscapes: true, &#125; &#125;);&lt;/script&gt;&lt;script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\"&gt;&lt;/script&gt; 最后一行那里的src，有些博客包括官方教程些的都是http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML，然而在https下此网址被认为是不安全的而一些浏览器被屏蔽了（比如Chrome），所以需要换成这个网址。 然后你需要检查下_config.yml中是否有如下一行：1markdown: kramdown 如果没有添加上即可。这是在指定markdown的解释器，如果你想换成其他的也可以。 至此，Mathjax配置完成了。用在行内用$来包裹latex公式，行间公式需要用$$包裹住。例子如下：12345blabla$x$blabla$$P(y|x)$$ 添加代码高亮我选择的是Jekyll原生支持的rouge进行代码高亮。只需要在_config.yml中添加一行：1highlighter: rouge 即可高亮代码。 最后的检测现在你已经配好了所有功能，在git仓库的根目录下运行jekyll serve即可以迅速在本地生成博客。通过浏览器访问localhost:4000即可看到成果啦喵～ 最后的最后记得push到你Github的远程仓库中，然后就可以在网页上看到你自己的博客了。","categories":[],"tags":[{"name":"Github.io","slug":"Github-io","permalink":"https://lrscy.github.io/tags/Github-io/"},{"name":"Jekyll","slug":"Jekyll","permalink":"https://lrscy.github.io/tags/Jekyll/"},{"name":"Mathjax","slug":"Mathjax","permalink":"https://lrscy.github.io/tags/Mathjax/"}]},{"title":"「译」GPU神经网络机器翻译导论（第一部分）","slug":"Trans-Intro-to-NMT-with-GPUs-part1","date":"2017-04-28T16:00:00.000Z","updated":"2017-11-09T16:33:26.491Z","comments":true,"path":"2017/04/29/Trans-Intro-to-NMT-with-GPUs-part1/","link":"","permalink":"https://lrscy.github.io/2017/04/29/Trans-Intro-to-NMT-with-GPUs-part1/","excerpt":"","text":"原文名：Introduction to Neural Machine Translation with GPUs (part 1) 翻译自 NVIDIA 深度学习系列 Theano 「译者注：博文中有些链接指向google drive，需要各位同学科学上网查阅资料。」 注意：这篇是Kyunghyun Cho写的神经网络机器翻译系列中的第一篇。其余的请见第二部分和第三部分。 神经网络机器翻译是近期被提出的的一个框架，其只基于神经网络。此篇文章是该系列的第一篇文章，我将阐述一个简单的编码-解码模型来构建一个神经网络机器翻译系统「Cho et al., 2014; Sutskever et al., 2014; Kalchbrenner and Blunsom, 2013」。后面的文章我将阐述如何将注意力机制融入简单的编码-解码模型中「Bahdanau et al., 2015」，并且形成好的英法、英德、英土和英中翻译模型「Gulcehre et al., 2015; Jean et al., 2015」。此外，我将介绍一些近期最新的进展——将此神经网络机器翻译框架应用于描述图像和视频的。 统计机器翻译首先，我们简单的阐述下机器翻译。事实上，机器翻译是个统称。我们希望机器将一种语言（我们称之为源语言）翻译成另一种语言（我们称之为目标语言）。（尽管理想情况下，机器应该能够将一整篇文档从一种语言翻译到另一种语言，但是我们在此篇博客中专注于句子级别的机器翻译。） 我们有许多方式去构建一台能够翻译语言的机器。例如，我们可以请教一个同时会两门语言的的人为我们构建一套翻译规则来将源语言正确的翻译成目标语言。但是这不是一个好的解决方案，联想下我们自己，我们可能都无法完整的构建出我们母语的语法规则，更别提构建两个语言规则之间的对应了。写一套详尽的翻译规则将源语言翻译成目标语言更是痴心妄想。因此，在此篇博文中，我们将专注于利用统计的方法，通过大量的文本语料库来提取这些隐式和显式的规则。 这种通过统计方法进行机器翻译的方法被成为统计机器翻译。虽然最终目标是相同的（建立一个能将一个句子从一种语言翻译到另一种语言的机器），但是我们让机器从数据中学习如何翻译而非学习如何构建规则（如图1的图解）。此学习是基于统计的方法，每个学习过机器学习的人都应该很熟悉此方法。事实上，统计机器翻译只是机器学习的一种特定的应用——寻找一种从源语言到相关目标语言的对应关系。 Figure 1. 图1. 统计机器翻译 机器翻译的一个重要的特征是翻译函数并非像其他机器学习应用一样是一对一的或多对一的（例如分类应用的函数就是多对一的），而是一对多的，也就是说一个源句子可能有多个可能的翻译结果。正因如此，模型的方法不是个确定性函数而是一个目标句子$y$对$x$的条件概率$p(y|x)$。条件概率能够对于多个分离度良好的结构或句子分配同等的高概率，这就使得源语言和目标语言的一对多关系得以成立。 现在，我们假设你将建立一个统计机器翻译系统并且要将英语翻译成法语。第一步且可能是最重要的一步是收集平行语料。我们用$x^n$和$y^n$来分别表示源语句和对应的翻译语句。上标$n$代表这是第$n$对语句（通常我们需要成千上万对语句才能训练出一个好的翻译模型）。我将用$D={(x^1,y^1), …, (x^N, y^N)}$来表示数据中有$N$对语句对。 我们从哪里能得到这些训练语句对呢？对于机器翻译中广泛使用的语言，你可能想要查看统计机器翻译研讨会 (EMNLP)或者国际语言翻译研讨会 (IWSLT)。 在有了训练集$D={(x^1,y^1), …, (x^N, y^N)}$后，我们能够通过观察这个模型在训练集$D$上的表现给这个模型打分。这分数（我将称之为模型的对数似然）是该模型对每一对$(x^n, y^n)$的对数似然的平均值。利用机器翻译模型的概率解释，模型在每一对上的对数似然只是模型给这一对语料$\\log p(y^n | x^n, \\theta)$评估的对数概率有多高。然后，整个模型的在训练集上的打分如下： $$\\mathcal{L}(\\theta, D) = \\sum_{(x^n, y^n) \\in D} \\log p(y^n|x^n, \\theta)$$ 如果对数似然值$\\mathcal{L}$很低，说明该模型没有分配给正确翻译句对足够的概率，也意味着该模型将部分概率分配给了错误的翻译。所以，我们希望找到一种模型的结构或者参数$\\theta$来最大化对数似然或得分。 在机器学习中，这被称为最大似然估计。除此之外我们还有一个更重要的问题：我们如何建立模型$p(y|x, \\theta)$？ 统计机器翻译简述IBM T.J. 沃森研究中心「Brown et al., 1993等其他参考文献」在20多年前就已经提出并回答了如何建立条件分布模型。从那时起，统计机器翻译(SMT)的核心就是一个线性对数模型，我们用有许多特征的线性组合近似了$p(y|x)$的对数： $$\\log p(y|x) \\approx \\log p(y|x, \\theta) = \\sum_i \\theta_i f_i(x, y) + C(\\theta),$$ 其中$C$是归一化常数。在这种情况下，很大一部分研究工作是要找到一组很好的特征函数$f_i$，并且有一本书已经详尽描述了关于其的所有细节「Koehn」。 在这种统计机器翻译方法中，通常来说机器学习需要做的只是寻找到一组能够平衡不同特征的系数$\\theta_i$，或者从对数线性模型「Schwenk, 2007」中筛选或重新排序一组可能的翻译。更具体来所，神经网络已经被用作组成特征函数功能的一部分，也可以用来重新排序所谓的最佳可能翻译的列表，就像图2中中间和右边部分。 Figure 2. 图2. 图解NMT，SMT+神经网络重新排序和SMT-NN。从「Bahadanau et al., 2015」在ICLR2015中的幻灯片中截取 另一方面，在此篇博客中，我将专注于最近提出一种称为神经网络机器翻译的方法。其中机器学习，特别是神经网络，拥有更多甚至全部的控制权。正如图2中左边部分所展示的。 神经网络机器翻译就像普通的深度学习一样，神经网络机器翻译(NMT)不依赖于已经提前设计好的方法。（通过提前设计好的方法，也就是说那些没有学习的功能。）相比而言，NMT设计的目标是设计一个完全可训练的模型，其每一部分都是基于语料库进行调整，以最优化其翻译表现。 一个完全可训练的NMT模型$\\mathcal{M}$从尽可能的地道的表述源语言语句开始训练，到生成尽可能地道的目标语言语句停止。目前，我们来考虑一个词序列视作作一个句子的最原始的表示。（虽然对于大多数语言来说这并不合理，但是在尽可能的保证一般性的前提下，我会将词作为一个语言的最小的单位。）每一个序列中的词都被它在字典中的索引数字代替。例如，在基于词频率的英语词典中，第一个出现的词会被表示为整数1。我将用$X=(x_1, x_2, \\cdots, x_T)$来表示源句子，用$Y=(y_1, y2, \\cdots, y{T’})$来表示目标句子。 给出源句子$X=(x_1, x_2, \\cdots, x_T)$的词索引，NMT模型$\\mathcal{M}$会计算$Y=(y_1, y2, \\dots, y{T’})$的条件概率。接下来，我将阐述我们如何来建立一个神经网络来近似条件概率$p(Y|X)$。 循环神经网络机器翻译的一个重要的特征，或是说基于自然语言的任何任务，是处理可变长度输入$X=(x_1, x_2, \\dots, x_T)$和可变长度输出$Y=(y_1, y2, \\dots, y{T’})$。换句话说，$T$和$T’$不固定。 为了处理这些可变长度的输入和输出，我们需要用到循环神经网络（RNN）。目前广泛应用的前馈神经网络（比如卷积神经网络）除了网络自身的参数外不保留中间状态。无论何时，一个样例进入前馈神经网络，无论网络内部参数还是隐藏层的激活都是重新计算的而不受前一个样本的状态结果的影响。然而RNN在读入一个序列时保存了其内部状态（在当前情况下是词序列），因此能够处理任何长度的输入。 我接下来将更详细的解释一下RNN。RNN的主要的思想是通过使用递归将输入的序列压缩成一个固定维度的向量。假设在第$t$步我们有一个向量$h{t-1}$保存了之前所有的符号的状态。RNN将计算出一个新的向量（或称为内部状态），$h{t}$通过下式压缩了之前所有符号$\\left( x_1, x2, \\dots, x{t-1} \\right)$包括新的符号$x_{t}$： $$ht = \\phi{\\theta}(xt, h{t-1})$$ 其中$\\phi{\\theta}$是由$\\theta$参数化的一个函数，以新符号$x{t}$和保存了前($t$-1)个符号的历史状态$h_{t-1}$作为输入。最开始，我们可以放心的假设$h_0$是一个全零向量。 Figure 3. 图3. 图解不同类型的循环神经网络。摘自「Pascanu et al., 2014」 递归激活函数$\\phi$通常被实现为一个非线性函数套着一个放射变换： $$h_t = \\tanh(W xt + U h{t-1} + b)$$ 在这个等式中，参数包括输入权重矩阵$W$，循环权重矩阵$U$和一个偏差向量$b$。我必须强调这不是唯一的实现方案，现在依旧有很多的机会来设计新的循环激活函数。见图三的一些例子「Pascanu et al., 2014」。 这种简单的RNN可以轻易的由Theano来实现，且Theano可以让你的RNN程序在CPU和GPU下透明的运行。详见循环神经网络实现词向量；注意，整个RNN代码总共不超过10行！ 最近，研究发现用更复杂的激活函数来训练循环神经网络有更好的效果且更加容易，比如LSTM「Hochreiter and Schmidhuber, 1997」和GRU「Cho et al., 2014」。 $$\\begin{align}r_t &amp; = \\sigma(W_r x_t + Ur h{t-1} + b_r) \\u_t &amp; = \\sigma(W_u x_t + r_t \\odot (Uu h{t-1}) + b_u) \\h_t &amp; = ut \\odot h{t-1} + (1-u_t) \\odot \\tanh(W x_t + r_t \\odot(Uu h{t-1}) + b)\\end{align}$$ 正如上述情况下的简单循环激活函数，参数包括了输入矩阵$W$（$W_r$和$W_u$），循环神经矩阵$U$（$U_r$和$U_u$）和偏差向量$b$（$b_r$和$b_u$）。 虽然这些单元看起来比简单RNN复杂些，但是由Theano或者其他深度学习框架（比如Torch）实现起来会很简单。例如LSTM网络进行情感分析(样例代码)。 我已经将RNN表述为了一个历史压缩器，但是它也可以用来为一个序列进行概率建模。给一个序列进行概率建模的意思是让机器学习一个模型来计算任意给定序列$X=(x_1, x2, \\dots, x{T})$的概率$p(X)$。我们如何设计$p(X)$才能让其满足递归的形式呢？ 我们从重新将$p(X) = p(x_1, x2, \\dots, x{T})$描述为下式开始： $$p(x_1, x2, \\dots, x{T}) = p(x_1) p(x_2 | x_1) p(x_3 | x_1, x_2) \\cdots p(x_T | x1, \\dots, x{T-1})$$ 上述改变基于条件概率公式，$p(X|Y) = \\frac{P(X, Y)}{P(Y)}$。从上述改变我们可以看出，我们可以设计出一个递归表达式，例如： $$p(x_1) p(x_2 | x_1) p(x_3 | x_1, x_2) \\cdots p(x_T | x1, \\dots, x{T-1}) = \\prod_{t=1}^T p(xt | x{&lt;t})$$ 现在我们使一个RNN模型$p(xt|x{&lt;t})$在每一步$t$时进行如下操作： $$p(xt | x{&lt;t}) = g{\\theta}(h{t-1}) \\h{t-1} = \\phi{\\theta}(x{t-1}, h{t-2})$$ $g{\\theta}$通过$h{t-1}$输出基于前($t$-1)个符号全部历史状态的条件分布概率。换句话说，在每个时刻，RNN试图通过学习输入符号的历史数据预测下一个字符应该是什么。 RNN有许多有趣的属性和特点值得我用上好几个小时来讲述，但是由于这是个博客，我不得就此停止。自此以后，我将讲述你们开始建立神经网络系统前的所有必备的知识。如果你想对RNN有更多的了解的话，我建议你去阅读下述论文。但是很明显，这些论文也并不能穷尽所有RNN有关的知识。你也可以去看我的关于如何将RNN应用于语言模型的幻灯片。 Graves, Alex. “Generating sequences with recurrent neural networks.” arXiv preprint arXiv:1308.0850 (2013). Pascanu, Razvan et al. “How to construct deep recurrent neural networks.” arXiv preprint arXiv:1312.6026 (2013). Boulanger-Lewandowski, Nicolas, Yoshua Bengio, and Pascal Vincent. “Modeling temporal dependencies in high-dimensional sequences: Application to polyphonic music generation and transcription.” arXiv preprint arXiv:1206.6392 (2012). Mikolov, Tomas et al. “Recurrent neural network based language model.” INTERSPEECH 2010, 11th Annual Conference of the International Speech Communication Association, Makuhari, Chiba, Japan, September 26-30, 2010 1 Jan. 2010: 1045-1048. Hochreiter, Sepp, and Jürgen Schmidhuber. “Long short-term memory.” Neural computation 9.8 (1997): 1735-1780. Cho, Kyunghyun et al. “Learning phrase representations using rnn encoder-decoder for statistical machine translation.” arXiv preprint arXiv:1406.1078 (2014). Bengio, Yoshua, Patrice Simard, and Paolo Frasconi. “Learning long-term dependencies with gradient descent is difficult.” Neural Networks, IEEE Transactions on 5.2 (1994): 157-166. 接下来的要讲述的事情在这篇博文中，我介绍了机器翻译，描述了统计机器翻译如何解决机器翻译的问题。在讲述统计机器翻译框架时，我讨论了神经网络如何用来提高翻译的整体表现。 这系列博客的目标是介绍一个新的神经网络机器翻译模型；这篇博文奠定了基础，重点介绍了循环神经网络的两个核心能力：序列总结能力和序列概率建模能力。 基于这两个特性，在下一篇博客中，我将讲述一个完整的基于循环神经网络的神经网络机器翻译系统。我也会想你展示为什么GPU对于神经网络机器翻译这么重要！","categories":[],"tags":[{"name":"NMT","slug":"NMT","permalink":"https://lrscy.github.io/tags/NMT/"},{"name":"GPU","slug":"GPU","permalink":"https://lrscy.github.io/tags/GPU/"},{"name":"Theano","slug":"Theano","permalink":"https://lrscy.github.io/tags/Theano/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"https://lrscy.github.io/tags/Deep-Learning/"}]}]}